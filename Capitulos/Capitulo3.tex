\chapter{Implementación}

% TODO: Explicar concretamente lo que se está implementando tanto en backend como en frontend. 

\section{Implementación del frontend}

El frontend de la aplicación web se realiza con React utilizando los lenguajes de programación \textit{javascript}, \textit{HTML}, y \textit{CSS}.\\

Para la comunicación del frontend con el backend mediante WebSockets se utiliza la librería \textit{reconnecting-websocket} \cite{reconect-ws}. Se decide utilizar esta frente a otras porque reconecta automáticamente con el servicio si la conexión se cierra por alguna razón y es compatible con \textit{WebSocket Browser API} \cite{api-ws-front}. \\


% TODO: explicar que se recibe directamente la información a mostrar, qué es lo que se trata o no (por ejemplo el ordenar por actual que se realiza en el frontend, el filtrado por plantas, el procesado para el mapeado por habitaciones y prioridad).
La aplicación web es una aplicación visual, en la que no se puede realizar ninguna acción sobre las alertas. Se recibe por websockets toda la información necesaria a monitorizar que procesa el nuevo servicio implementado en PAServidor. Por esta razón, la mayoría de la implementación de esta parte del proyecto se centra en interfaz de usuario aunque también se realiza el tratado de la información que llega para tener los datos de la manera indicada. Cabe destacar que el filtrado por plantas de las alertas, la ordenación de las alertas por más actuales, el filtrado de alertas por prioridad y el mapeado por habitaciones, se realiza en esta parte del proyecto.\\


% Indicar otras librerías utilizadas en el proyecto
Para implementar la aplicación web se ha considerado útil contar con el apoyo de ciertas librerías. Algunas interesantes de mencionar son:
\begin{itemize}
	\item \textit{Bootstrap} \cite{bootstrap} y \textit{React-Bootstrap} \cite{react-bootstrap} como herramientas para la implementación de la interfaz de usuario.
	\item \textit{react-multi-carousel} \cite{react-multi-carousel} para mostrar el carrusel de alertas en una de las pantallas principales de la aplicación.
	\item \textit{react-icons} \cite{react-icons} ya que provee distintos tipos de iconos para la aplicación.
	\item \textit{react-moment} \cite{react-moment} como apoyo para utilizar las fechas y horas de las alertas y ordenarlas para mostrar en el carrusel las más actuales primero.
	\item \textit{react-img-mapper} \cite{react-img-mapper} para facilitar el mapeado de las áreas de las habitaciones en los planos de las plantas y poder mostrar al usuario las habitaciones coloreadas por prioridad junto con el icono de la alerta con más prioridad dentro de dicha habitación y la tarjeta emergente con la información de dicha alerta.
\end{itemize}

 % Explicar organización de ficheros en frontend indicando que cierta división de los módulos hace que la organización del código queda bien repartida teniendo las funcionalidades para poder ver a simple vista implementado

Durante el desarrollo de la aplicación se ha seguido cierta estructura a la hora de dividir los módulos para organizar el código. De esta forma, ha sido más fácil realizar una implementación clara durante el desarrollo. Además, de cara a que la empresa pueda reutilizar el código hace que sea más sencillo comprenderlo. Se puede ver la organización realizada  en tiempo de desarrollo con una vista de módulos en forma de diagrama de paquetes. (Véase \textit{Figura 3.1}).\\

% TODO: Diagrama de paquetes UML para explicar la organización.



\section{Implementación del backend}

El backend de la aplicación se realiza con \textit{.NET Framework 4.8}, ya que como se ha explicado en secciones anteriores la implementación es añadir funcionalidad a la aplicación existente. \\

Para la comunicación con el frontend mediante WebSockets se utiliza la librería \textit{websocket-sharp} \cite{websocket-sharp} en su versión \textit{1.0.3.0}.
Se decide utilizar esta librería ya que en otra de las funcionalidades existente en la aplicación se utiliza (aunque en una versión anterior), y se cree conveniente utilizar algo similar de cara a que internamente en la empresa puedan entender mejor la implementación o reutilizar el código.
La instalación de esta librería se realiza mediante el propio Visual Studio (que se ha comentado la sección de herramientras de trabajo que es el entorno de desarrollo utilizado para implementar el backend) utilizando la opción de administrar paquetes NuGet e instalando el nombrado. \\

Al principio la empresa propuso realizar la comunicación del backend con el frontend utilizando \textit{SignalR} \cite{signalr} pero finalmente se descarta por incompatibilidad con la aplicación actual y simplicidad en la arquitectura software. Se puede ver más información referente a esta decisión en el \hyperref[anexo-b]{Anexo B}. \\


% Explicar qué SERVICIO implemento dentro de la arquitectura
De los servicios y eventos nombrados en la arquitectura detallada del PAServidor en la \hyperref[section-arquitectura]{sección 2.2}, el servicio que se ha implementado para añadir funcionalidad a la aplicación existente y que sirve como backend de la aplicación web, es el \textit{Servicio de monitorización web} que se puede observar en la sección nombrada, concretamente en la \hyperref[fig:PAServidor]{\textit{Figura 2.2}}.\\

% Explicar comportamiento de servicios y eventos
\subsection{Comportamiento servicios y eventos}
\label{subsection-comportamiento}
% TODO: DIAGRAMAS DE COMPORTAMIENTO para mostrar ejemplo/s de funcionamiento interno.
Respecto al comportamiento de los servicios y eventos implicados, a continuación se exponen unos ejemplos de funcionamiento.\\

El funcionamiento para el caso de las alarmas es el siguiente:
\begin{enumerate}
	\item El paciente pulsa el botón del terminal para solicitar ayuda.	
	\item El terminal notifica al Servicio de Comunicación con Terminales, mediante el socket, que alguien ha pulsado el botón.
	\item El servicio comunicación con terminales envía un evento \textit{NuevaAlarma} con toda la información relativa al terminal.
	\item El servicio de alarmas, que está suscrito al evento \textit{NuevaAlarma}, recibe el evento y lo procesa. Es necesario acceder a la base de datos para obtener información necesaria. Como resultado envía un evento \textit{NotificarAlarmaEnMonitorWeb}.
	\item El servicio de monitorización web recibe el evento \textit{NotificarAlarmaEnMonitorWeb} al que está suscrito y lo procesa, envíando mediante websocket la información conveniente a la aplicación web.
	\item En la aplicación web aparecerá la nueva alarma.
	\item El Servicio de Monitorización web recibe el evento \textit{SAEvento\_NuevaAccionPendiente} cuando se producen alarmas y lo procesa si le ha llegado el evento \textit{NotificarAlarmaEnMonitorWeb} para actualizar la alarma indicada, y el resultado de la actualización es envíado mediante el websocket a la aplicación web.
	\item En la aplicación web aparecerá la alarma actualizada.
	\item El Servicio de Monitorización web recibe el evento \textit{SAEvento\_DisparoAvisoFinalizado} cuando se codifica una alarma y lo procesa si le ha llegado el evento de \textit{NotificarAlarmaEnMonitorWeb} para eliminar la alarma indicada, y el resultado de la actualización es envíado mediante el websocket a la aplicación web.
	\item En la aplicación web desaparecerá la alarma actualizada.
\end{enumerate}

El funcionamiento para el caso de las presencias es el siguiente:

\begin{enumerate}
	\item Un trabajador se identifica en la habitación pasando su tarjeta personal por el lector o con el su PIN.
	\item El terminal notifica al Servicio de Comunicación con Terminales, mediante el socket, que alguien está presente.
	\item El Servicio de Comunicación con Terminales envía un evento \textit{NuevaPresencia} con toda la información relativa a la presencia.
	\item El servicio de alarmas que está suscrito al evento \textit{NuevaPresencia} recibe el evento y lo procesa. Es necesario acceder a la Base de Datos para obtener información necesaria. Como resultado envía un evento \textit{PAEvento\_NotificarEstadoPresencias}.
	\item El servicio de monitorización web recibe el evento \textit{PAEvento\_NotificarEstadoPresencias} que puede ser de las presencias actuales, de una presencia nueva, actualizada o eliminada y lo procesa. Como resultado envía la información necesaria mediante el websocket a la aplicación web.
	\item En la aplicación web aparece, se actualiza o desaparece la presencia.
\end{enumerate}


% TODO: Mirar en mis notas todas las decisiones y controversisas con backend
TODO: Decisiones de implementación respecto a ficheros y funciones que tengo anotadas y problemas u opciones surgidas respecto a la implementación del backend\\
